
import os, sys, datetime, inspect, struct, time, argparse, pyshark
import numpy as np
import random
from struct import *
from time import sleep
from copy import deepcopy
from warnings import filterwarnings
filterwarnings("ignore")

from pyasn1.codec.ber import decoder
from pyasn1.codec.ber import encoder
from pyasn1.type import char
from pyasn1.type import tag
from pyasn1.type import univ
from scapy.layers.l2 import Ether
from scapy.layers.l2 import Dot1Q
from scapy.compat import raw
from scapy.utils import hexdump
from scapy.utils import wrpcap
from scapy.all import rdpcap
from scapy.all import sendp


from goose.goose import GOOSE
from goose.goose import GOOSEPDU
from goose.goose_pdu import AllData
from goose.goose_pdu import Data
from goose.goose_pdu import IECGoosePDU
from goose.goose_pdu import UtcTime


##################################################### DEFINED FUNCTIONS  ##################################


# CONVERTING THE TIME INTO 64-BITS or 8-BYTES FORM
UTC = 1 # 0: local time 1: UTC Time
def curTime64Bits(utc=False):
    # Microsecond Resolution Ignored
    if UTC:
        curTime = time.mktime(datetime.datetime.utcnow().timetuple())
    else:
        curTime = time.mktime(datetime.datetime.now().timetuple())

    curTimeInt = int(curTime)
    curTimeInt64 = (curTimeInt << 32)
    curTimeInt64Str = curTimeInt64.to_bytes(8,'big')
    return curTimeInt64Str


# This function will check whether the packets is a GOOSE packet or not
def goose_check(packet, GOOSE_TYPE):
    isGoose = False
    # Test for a Goose Ether Type
    if packet.haslayer('Dot1Q'):
        if packet['Dot1Q'].type == GOOSE_TYPE: isGoose = True
    if packet.haslayer('Ether'):
        if packet['Ether'].type == GOOSE_TYPE: isGoose = True
    return isGoose

# This function will print all the ANS.1 decoded GOOSE PDU data 
def gooseASN1_DataPrint(data):
    print('\n\n')
    for field in list(IECGoosePDU()):
        if not data[field].hasValue():
            continue
        if type(data[field]) == char.VisibleString:
            print('%s: %s'%(field,str(data[field])))
            continue
        if type(data[field]) == univ.Integer:
            print('%s: %s'%(field,int(data[field])))
            continue
        if type(data[field]) == UtcTime:
            print('%s: %s'%(field,datetime.datetime.fromtimestamp(int.from_bytes(bytearray(data[field])[:4],'big')).strftime('%Y-%m-%d %H:%M:%S')))
            continue
        if type(data[field]) == univ.Boolean:
            print('%s: %s'%(field,str(data[field])))
            continue
        if type(data[field]) == AllData:
            print('%s'%(field))
            for field in data.getComponentByName('allData'):
                for value in field.values():
                    print('    %s'%(value))
            continue
        if type(data[field]) == univ.OctetString:
            print('%s: %s'%(field,str(data[field])))
            continue

# This function will decode the GOOSE PDU header using ASN.1 decoding 
def gooseAllData_decode(encoded_data):
    g = IECGoosePDU().subtype(
        implicitTag=tag.Tag(
            tag.tagClassApplication,
            tag.tagFormatConstructed,
            1
        )
    )

    decoded_data, unprocessed_trail = decoder.decode(
        encoded_data,
        asn1Spec=g
    )

    return decoded_data

# This function Filters packets based on source and destination MAC addresses
def filter_packets(pkt, src_mac, dst_mac):
    if pkt.haslayer(Ether):
        return pkt[Ether].src == src_mac and pkt[Ether].dst == dst_mac
    return False

